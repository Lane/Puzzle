<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Objects/PieceContainer.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Objects/PieceContainer.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * Represents a container that holds Pieces
 *
 * @constructor
 * @augments createjs.Container
 * @param {Object} options Option overrides
 * @property {Array} _pieces - The pieces inside this container
 * @property {boolean} _selected - The selected status of this PieceContainer
 * @property {RotateHandle} _rotateHandle - Control used to rotate the PieceContainer
 * @property {Puzzle} _puzzle - The puzzle that this PieceContainer belongs to
 * @property {Boundary} boundary - The boundary of this piece container
 */
function PieceContainer(options) {
	
	this._pieces = options.pieces || new Array();
	this._selected = false;
	this._rotateHandle = new RotateHandle();
	this._puzzle = null;
	this._snapped = false;
	this.boundary = new Boundary(9999, 9999, (2*-9999), (2*-9999));
	
	this.initialize(options);
	
}

var pc = PieceContainer.prototype = new createjs.Container();

pc.Container_initialize = pc.initialize;

// INITIALIZER
// --------------------

pc.initialize = function(options) {
	this.Container_initialize(options);
	
	// set parameters
	this.name = options.name || "container"+this.id;
	this.cursor = options.cursor || "pointer";
	this.x = options.x || 250;
	this.y = options.y || 250;
	this._selected = false;
	this.type = "piece-container";
	
	for(var i=0; i &lt; this._pieces.length; i++) {
		if(typeof(this._pieces[i].parent) == "undefined" 
			|| this._pieces[i].parent == null) {
			this._pieces[i].parent = this;
		}
	}
	
	var _this = this;
	
	// Piece container interaction events
	this.addEventListener("mouseover", function(event) { 
		_this._puzzle.mouseOverPiece.notify({ 
			event: event, 
			pieceContainer: _this
		});
	});
	
	this.addEventListener("mouseout", function(event) { 
		_this._puzzle.mouseOutPiece.notify({ 
			event: event, 
			pieceContainer: _this
		});
	});
	
	this.addEventListener("mousedown", function(event) {
	
		var pc = event.target;
		var offset = {x:pc.x-event.stageX, y:pc.y-event.stageY};
		var ob = pc.parent.getObjectUnderPoint(event.stageX, event.stageY);
		
		// if the user pressed down on a piece
		if(ob.type !== null) {
			if(ob.type == "piece") {
				event.addEventListener("mousemove", function(evt) {
					evt.offset = offset;
					_this._puzzle.dragPiece.notify({ 
						event: evt, 
						pieceContainer: _this
					});
				});
			}
			
			// if the user pressed down on the rotate handle
			if(ob.type == "rotate-handle") {
				var start = ob.parent.rotation;
				offset = {x:event.stageX, y:event.stageY};
				event.addEventListener("mousemove", function(evt) {
					evt.offset = offset;
					evt.start = start;
					_this._puzzle.dragRotateHandle.notify({ 
						event: evt, 
						pieceContainer: _this
					});
				});
			}
		}
		
		// check if any pieces match once the user lets go
		event.addEventListener("mouseup", function(evt) {
			_this._puzzle.releasePiece.notify({ 
				event: evt, 
				pieceContainer: _this
			});
		});
		
	});
	
	this.setBoundary();
	
	this.addChild(this._rotateHandle);	
}

// SETTERS
// --------------------

/**
 * Sets the boundary for the piece container.
 * @method PieceContainer..setBoundary
 * @returns {PieceContainer} This piece container
 **/
pc.setBoundary = function() {
	// our box: left, right, top, bottom
	var box = new Boundary(9999, 9999, (2*-9999), (2*-9999));
	
	// extend the boundary by each piece
	for(var i = 0; i &lt; this._pieces.length; i++) {
		box.extendBoundary(this._pieces[i].getPieceBoundary());
	}
	
	var offSet = box.center;
	
	// update this boundary
	this.boundary = box;
	this.boundary.top += this.y-offSet.y;
	this.boundary.left += this.x-offSet.x;
	this.boundary.bottom += this.y-offSet.y;
	this.boundary.right += this.x-offSet.x;
	return this;
}

/**
 * Sets the cache for the piece container. The cache puts the area 
 * specified in a separate canvas to conserve resources.
 * @method PieceContainer..setCache
 * @returns {PieceContainer} This piece container
 **/
pc.setCache = function() {
	var b = this.getPieceContainerBoundary();
	this.cache(b.left, b.top, b.width, b.height);
	return this;
}


// GETTERS
// --------------------

/**
 * Gets the pieces inside this piece container
 * @method PieceContainer.getPieces
 * @returns {Array} An array of pieces inside this container
 **/
pc.getPieces = function () {
  return this._pieces;
}

/**
 * Gets the bounding box of this piece container relative to the stage
 * @method PieceContainer.getBoundingBox
 * @returns {Boundary} The boundary relative to the stage
 **/
pc.getBoundingBox = function() {
	return this.boundary;
}

/**
 * Gets the boundary of this piece container relative to the center point
 * @method PieceContainer.getPieceContainerBoundary
 * @returns {Boundary} The boundary relative to the center point
 **/
pc.getPieceContainerBoundary = function() {
	return new Boundary(
		this.boundary.left-this.x+this.boundary.center.x, 
		this.boundary.top-this.y+this.boundary.center.y,
		this.boundary.width,
		this.boundary.height
	);
}

// METHODS
// --------------------
	
/**
 * Adds a piece to the piece container 
 * @method PieceContainer.addPiece
 * @param {Piece} p Piece to add to the container
 * @returns {PieceContainer} This piece container
 **/
pc.addPiece = function (p) {
  this._pieces.push(p);
  p.parent = this;
  
  // update this container boundary
  this.setBoundary();
  
  // save the old reg point
  var oldReg = { x: this.regX, y: this.regY };
  
  // set the new reg point to the center of the bounding box
  this.regX = this._rotateHandle.x = this.boundary.getCenter().x;
  this.regY = this._rotateHandle.y = this.boundary.getCenter().y;
  
  // determine the reg point difference and set position
  var regDiff = { x: this.regX-oldReg.x, y: this.regY-oldReg.y };
  this.x += regDiff.x;
  this.y += regDiff.y;
  
  // notify that a piece has been added
  this._puzzle.pieceAdded.notify({ piece : p });
  return this;
}

/**
 * Sets the position of the piece container
 * @method PieceContainer.movePiece
 * @param {int} x The x position to move the piece container to
 * @param {int} y The y position to move the piece container to
 * @returns {PieceContainer} This piece container
 **/
pc.movePiece = function(x,y) {
	// set the position
	this.x = x;
	this.y = y;
	
	// update the boundary if we're not snapped
	if(!this._snapped) {
		this.boundary.top = this.y-this.boundary.height/2;
		this.boundary.left = this.x-this.boundary.width/2;
		this.boundary.bottom = this.y+this.boundary.height/2;
		this.boundary.right = this.x+this.boundary.width/2;
	}
	return this;
}

/**
 * Sets the rotation of the piece container
 * @method PieceContainer.rotatePiece
 * @param {Event} The rotate handle drag event
 * @returns {PieceContainer} This piece container
 **/
pc.rotatePiece = function(e) {
	this.rotation = e.start + ((e.stageX-e.offset.x)+(e.stageY-e.offset.y));
	return this;
}

/**
 * Removes a piece from the container
 * @method PieceContainer.removePiece
 * @param {Piece} p The piece to remove from the container
 * @returns {boolean} true or false depending on if the piece was removed
 **/
pc.removePiece = function (p) {
	for(var i = 0; i &lt; this._pieces.length; i++) {
		if(this._pieces[i].id == p.id)
		{
			this._pieces.remove(i);
			this._puzzle.pieceRemoved.notify({ piece : p });
			return true;
		}
	}
	this.setBoundary();
	return false;
}

/**
 * Adds selected treatments to this PieceContainer
 * @method PieceContainer.selectPiece
 * @returns {PieceContainer} This piece container
 **/
pc.selectPiece = function() {
	this.addChild(this._rotateHandle);
	this._selected = true;
	this._rotateHandle.visible = true;
	this.parent.addChild(this);
	this.filters = [new createjs.ColorFilter(1, 1, 0.6, 1)];
	return this;
}

/**
 * Sets a hover filter on the piece container
 * @method PieceContainer.hoverPiece
 * @returns {PieceContainer} This piece container
 **/
pc.hoverPiece = function() {
	if(!this._selected) {
		this.filters = [new createjs.ColorFilter(0.8, 1, 0.8, 1)];
	}
	return this;
}

/**
 * Removes the filters and selected status from a piece if forced.
 * @method PieceContainer.resetPiece
 * @param {boolean} force Set to true if resetting selected piece
 * @returns {PieceContainer} this piece container
 **/
pc.resetPiece = function(force) {
	force = typeof force !== 'undefined' ? force : false;
	if(!this._selected || force) {
		this._selected = false;
		this._rotateHandle.visible = false;
		this.filters = [];
	}
	return this;
}

/**
 * Goes through all of the pieces in the container and checks if any 
 * of them are matched with their pair. If there are any matches, the 
 * pieces are connected.
 * @method PieceContainer.matchPieces
 * @return {PieceContainer} This piece container
 **/
pc.matchPieces = function() {
	for(var i = 0; i &lt; this._pieces.length; i++) {
		var matches = this._pieces[i].getMatches();
		for(var j = 0; j &lt; matches.length; j++) {
			this._puzzle.connectPointWithMatch(matches[j]);
			debug.log(matches[j], "Match has been made");
		}
	}
	return this;
}

/** 
 * Checks if the current piece container is within the radius of any matches,
 * and if it is, the piece container will "snap" to its matched position.
 * @method PieceContainer.snapToMatch
 * @return {PieceContainer} This piece container
 **/
pc.snapToMatch = function() {
	this._snapped = false;
	for(var i = 0; i &lt; this._pieces.length; i++) {
		var matches = this._pieces[i].getMatches();
		if(matches.length > 0) {	// we're only gonna snap to one
			var m = matches[0];
			
			var offsets = [
				m.getStageOffset(), 
				m.getMatch().getStageOffset()
			];
			var difference = { 
				x: 	offsets[0].x-offsets[1].x,
				y: 	offsets[0].y-offsets[1].y
			};
			this.set({
				x: this.x-difference.x, 
				y: this.y-difference.y
			});
			this._snapped = true;
			this.boundary.top = this.y-this.boundary.height/2;
			this.boundary.left = this.x-this.boundary.width/2;
			this.boundary.bottom = this.y+this.boundary.height/2;
			this.boundary.right = this.x+this.boundary.width/2;
		}
	}
	return this;
}

/**
 * Determines if this Piece Container is currently selected.
 * @method PieceContainer.isSelected
 * @return {boolean} True if this piece is selected, false if not
 **/	
pc.isSelected = function() {
	return this._selected;
}

/**
 * Goes through every point of every piece within this piece container 
 * and sets the angle, radius, and offset for the point.
 * @method PieceContainer.updatePoints
 * @return {PieceContainer} This piece container
 **/
pc.updatePoints = function() {
	for(var i = 0; i &lt; this._pieces.length; i++) {
		for(var j = 0; j &lt; this._pieces[i]._points.length; j++) {
			this._pieces[i]._points[j].updatePoint();
		}
	}
	return this;
}

/**
 * Goes through every point of every piece within this piece container 
 * and sets the offset of the point. Does not adjust the angle/radius 
 * of the point like updatePoints().
 * @method PieceContainer.updatePointsOffset
 * @return {PieceContainer} This piece container
 **/
pc.updatePointsOffset = function() {
	for(var i = 0; i &lt; this._pieces.length; i++) {
		for(var j = 0; j &lt; this._pieces[i]._points.length; j++) {
			this._pieces[i]._points[j].setOffset();
		}
	}
	return this;
}

/**
 * Get a string representation of the PieceContainer
 * @override
 * @method PieceContainer.toString
 * @this {PieceContainer}
 * @returns {string} Human-readable representation of this PieceContainer.
 */
pc.toString = function() {
	var b = this.boundary;
	var pcString = this.name + "\n"
		+ "Position: " + this.x + "," + this.y + "\n"
		+ "Rotation:" + this.rotation + "\n"
		+ "Centre:" + this.regX + "," + this.regY + "\n"
		+ "Dimensions: " + b.width + "," + b.height + "\n" 
		+ "Boundary: " + (b.left) + "," + (b.top) + " : " 
			+ (b.right) + "," + (b.bottom) + "\n";
	for(var i = 0; i &lt; this._pieces.length; i++) {
		pcString += this._pieces[i].toString();
	}
	
	return pcString;
}

/**
 * Get an html string representation of the PieceContainer
 * @method PieceContainer..toHTMLString
 * @this {PieceContainer}
 * @returns {string} HTML representation of this PieceContainer.
 */
pc.toHTMLString = function() {
	var pcString = "&lt;h3>" + this.name + "&lt;/h3>"
		+ "&lt;ul class='properties'>" 
		+ "&lt;li>&lt;span>Position: &lt;/span>" + this.x + "," + this.y + "&lt;/li>"
		+ "&lt;li>&lt;span>Rotation:&lt;/span>" + this.rotation + "&lt;/li>"
		+ "&lt;li>&lt;span>Centre: &lt;/span>" + this.regX + "," + this.regY + "&lt;/li>"
		+ "&lt;li>&lt;span>Dimensions: &lt;/span>" + this.boundary.width + "," 
		+ this.boundary.height + "&lt;/li>" + "&lt;li>&lt;span>Boundaries: &lt;/span>" 
		+ (this.boundary.left) + "," + (this.boundary.top) + " : " 
		+ (this.boundary.right) + "," + (this.boundary.bottom) + "&lt;li>";
	for(var i = 0; i &lt; this._pieces.length; i++) {
		pcString += this._pieces[i].toHTMLString();
	}
	pcString += "&lt;/li>&lt;/ul>";
		
	return pcString;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Boundary.html">Boundary</a></li><li><a href="Event.html">Event</a></li><li><a href="Piece.html">Piece</a></li><li><a href="PieceContainer.html">PieceContainer</a></li><li><a href="Point.html">Point</a></li><li><a href="Puzzle.html">Puzzle</a></li><li><a href="PuzzleBuilder.html">PuzzleBuilder</a></li><li><a href="PuzzleController.html">PuzzleController</a></li><li><a href="PuzzleView.html">PuzzleView</a></li><li><a href="RotateHandle.html">RotateHandle</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DEG2RAD">DEG2RAD</a></li><li><a href="global.html#RAD2DEG">RAD2DEG</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.0-dev</a> on Tue May 14 2013 15:16:28 GMT-0600 (MDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
